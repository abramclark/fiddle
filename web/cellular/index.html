<!DOCTYPE HTML>
<html>
<head>
<script>

let rules = {
  "identity": (a, b, c) => b,
  "drips": (a, b, c) => ((a + b + c) / 2.99) % 1,
  "mountains": (a, b, c) => (1.001 * Math.max( a + b, b + c ) / 2) % 1,
  "houses": (a, b, c) => (Math.min( a + b, b + c ) / 1.8) % 1,
  "stacks": (aa, bb, cc) =>{
    let a = aa*.9, b = bb, c = cc*.9, avg = (a + b + c) / 2.8
    return [a-b, a-c, b-c].findIndex(x => Math.abs(x) > .3333) == -1 ?
      avg * 1.01 : avg * .96
  },
  "triangles": (a, b, c) =>{
    let avg = (a + b + c) / 3
    return [a-b, a-c, b-c].findIndex(x => Math.abs(x) > .2) == -1 ?
        avg + Math.exp(avg) / 500 :
        Math.min(a + b, a + c, b + c) * .49
  },
  "triangle waves": (a, b, c) =>{
    let avg = (a + b + c) / 3
    return [a-b, a-c, b-c].findIndex(x => Math.abs(x) > .2) == -1 ?
        avg + .02 + Math.abs(Math.sin(t) + 1) / 30 :
        Math.min(a + b, a + c, b + c) * .49
  },
  "pi grey": (a, b, c) =>{
    let avg = (a + b + c) / 3
    return avg + Math.sin(avg)
  },
  "oil run": (a, b, c, i) => Math.random() > .001 ?
    (Math.random() > .05 ?
      (Math.random() < .3333 ? a : (Math.random() > .5 ? b : c)) :
      (a + b + c) / 3
    ) :
    (Math.sin(i / 318) / 2 + .5 + Math.sin(t) / 2 + .5)
},

rule = rules.triangles, width, cells, t = 0, neighbors = i =>
  [ cells[i > 0 ? i - 1 : width - 1], cells[i], cells[(i + 1) % width], i ],
cellulate = ()=>{
  t += .01
  return cells.map( (x, i) => rule(...neighbors(i)) )
},

draw, tiles, tileSize = 100, tileMargin = 0, tileOffset = 0, go = 1,
render = ()=>{
  tiles.forEach( (x, i) => draw.putImageData(
    x.getImageData(0, 0, width, tileSize), 0, i * tileSize - tileOffset ) )
  tileOffset += 1
  if(go) setTimeout(()=> requestAnimationFrame(render), 25)
  if(tileOffset > tileSize - tileMargin){
    renderTile(tiles[0])
    tiles.push(tiles.shift())
    tileOffset = 0
  }
},

renderTile = tile => range(tileSize).forEach(x =>{
  let cells2 = cellulate()
  tile.putImageData(cells2Img(cells), 0, x)
  cells = cells2
}),

$ = q => document.querySelector(q),
$$ = (q, fn)=>{
    let els = document.querySelectorAll(q)
    if(fn) els.forEach(fn)
    return els
},
 
ruleName = 'triangles', reset_rule = ()=>{
  ruleName = $('#rules').value
  rule = rules[ruleName]
  $('#rule').value = rule.toString()
},
cell_reset = i =>{ cells = new Float32Array([
  ()=> range(0, 1, 1/width),
  ()=> range(0, 1, 2/width).concat(range(0, 1, 2/width).reverse()),
  ()=> range(width).map(Math.random),
  ()=> {
      let l = Array(95).fill(0), out = []
      l = l.concat([1,1,1,1,1])
      while(out.length < width) out = out.concat(l)
      return out
  }
][i]()) },
toggles, play_pause = ()=>{
  toggles.forEach(el => el.classList.remove('on'))
  toggles[go+0].classList.add('on')
  go = !go
  if(go) render()
},
initUI = ()=>{
  Object.keys(rules).forEach(v => {
    let el = document.createElement('option')
    el.value = v; el.innerText = v
    if(v == ruleName) el.selected = true;
    $('#rules').appendChild(el)
  })
  reset_rule()
  $('#rules').onchange = reset_rule
  $('#set_rule').onclick = reset_rule
  $('#sel_reset').onchange = ()=> cell_reset($('#sel_reset').value)
  $('#reset').onclick = ()=> cell_reset($('#sel_reset').value)
  toggles = $$('.toggle', el => el.onclick = play_pause)
  $('#rule').onkeyup = ()=>{
    let f = 0
    try {
      f = eval($('#rule').value)
      f(0, 1, 2)
    } catch( ex ){
      $('#error').innerText = ex.message
    }
    if(f){
      rule = f
      $('#error').innerText = ''
    }
  }
},

height, init = ()=>{
  let canvas = $('canvas')
  draw = canvas.getContext('2d')
  width = canvas.width
  height = canvas.height
  cell_reset(0)
  tiles = range( Math.ceil(height / (tileSize - tileMargin)) + 1
    ).map( x => buff(width, tileSize) )
  tiles.forEach(renderTile)

  initUI()
  render()
},

cellColor = x => Math.abs(((x+1)/2 % 1 - .5) * 510),
cells2Img = cells =>{
  let img = new ImageData(width, 1)
  cells.forEach( (x, i) =>{
    [0,1,2].forEach(o => img.data[i*4+o] = cellColor(x) )
    img.data[i*4+3] = 255
  })
  return img
},

range = (start, end, step=1) =>{
  if( end === undefined ){ end = start; start = 0 }
  for(var l = []; start < end; start += step) l.push(start)
  return l
},

buff = (width, height) =>{
  let canvas = document.createElement('canvas')
  canvas.width = width; canvas.height = height
  return canvas.getContext('2d')
}

</script>
<style>

body { margin:0; height:100%; }
body > * { position:absolute; top:0; left:0; }
canvas { width:100%; height:100%; }
textarea { font-size:large; font-family:monospace; width:44em; height:7em;
  background:none; }
button { vertical-align:middle; font-size:larger; }
.toggle { display:none; }
.toggle.on { display:inline-block; width:3em; }
#ui {
  margin:2em; padding:1em;
  font-family:sans-serif;
  background-color:rgba(255,255,255,.9);
  position:fixed;
}
#error { color:red; }

</style>
</head>
<body onload='init()'>
<!-- <img src='sky.jpg'> -->
<canvas width='1000' height='700'></canvas>
<div id='ui'>
  <textarea id='rule'>
  </textarea><br>

  <button id='set_rule'>change rule:</button> <select id='rules'>
  </select> &nbsp;

  <button id='pause' class='toggle on'>stop</button>
  <button id='play' class='toggle go'>go</button> &nbsp;

  <button id='reset'>reset:</button> <select id='sel_reset'>
    <option value='0'>gradient
    <option value='1'>mirrored gradient
    <option value='2'>random
    <option value='3'>dots
  </select> &nbsp; &nbsp;

  <span id='error'></span>
</div>
</body>
</html>
